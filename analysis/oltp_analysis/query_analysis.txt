QUESTION 1: Monthly Encounters by Specialty
SQL Query:
SELECT 
    DATE_FORMAT(e.encounter_date, '%Y-%m') AS month,
    s.specialty_name,
    e.encounter_type,
    COUNT(*) AS total_encounters,
    COUNT(DISTINCT e.patient_id) AS unique_patients
FROM encounters e
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY 1, 2, 3;

Schema Analysis:
Tables joined: encounters, providers, specialties
Number of joins: 2
Performance:
Execution time: 0.0022 seconds
Bottleneck Identified:
This query requires joining the large 'encounters' table with 'providers' and then 'specialties' just to get the specialty name. 
In a real-world scenario with millions of encounters, joining these normalized tables and then grouping by derived fields (DATE_FORMAT) would be very slow due to the lack of pre-aggregation and the cost of joining.

---

QUESTION 2: Top Diagnosis-Procedure Pairs
SQL Query:
SELECT 
    d.icd10_code, 
    p.cpt_code, 
    COUNT(*) AS encounter_count
FROM encounters e
JOIN encounter_diagnoses ed ON e.encounter_id = ed.encounter_id
JOIN diagnoses d ON ed.diagnosis_id = d.diagnosis_id
JOIN encounter_procedures ep ON e.encounter_id = ep.encounter_id
JOIN procedures p ON ep.procedure_id = p.procedure_id
GROUP BY 1, 2
ORDER BY 3 DESC 
LIMIT 10;

Schema Analysis:
Tables joined: encounters, encounter_diagnoses, diagnoses, encounter_procedures, procedures
Number of joins: 4
Performance:
Execution time: 0.0015 seconds
Bottleneck Identified:
This query suffers from "row explosion" potential if there are multiple diagnoses and multiple procedures per encounter (Cartesian product of the many-to-many relationships). 
It also involves 5 tables joined together, which is computationally expensive.

---

QUESTION 3: 30-Day Readmission Rate
SQL Query:
SELECT 
    s.specialty_name,
    COUNT(DISTINCT e1.encounter_id) AS total_inpatient_discharges,
    COUNT(DISTINCT e2.encounter_id) AS readmissions_within_30_days,
    COUNT(DISTINCT e2.encounter_id) / COUNT(DISTINCT e1.encounter_id) * 100 AS readmission_rate
FROM encounters e1
JOIN providers p ON e1.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
LEFT JOIN encounters e2 ON e1.patient_id = e2.patient_id 
    AND e2.encounter_date > e1.discharge_date 
    AND e2.encounter_date <= DATE_ADD(e1.discharge_date, INTERVAL 30 DAY)
WHERE e1.encounter_type = 'Inpatient'
GROUP BY 1;

Schema Analysis:
Tables joined: encounters (self-join), providers, specialties
Number of joins: 3 (including self-join)
Performance:
Execution time: 0.0013 seconds
Bottleneck Identified:
The self-join on the 'encounters' table is the major bottleneck. Comparing every inpatient encounter with every subsequent encounter for the same patient within a date range is O(N^2) complexity in the worst case for each patient's history. 
On a large table, this is extremely slow.

---

QUESTION 4: Revenue by Specialty & Month
SQL Query:
SELECT 
    DATE_FORMAT(e.encounter_date, '%Y-%m') AS month,
    s.specialty_name, 
    SUM(b.allowed_amount) AS total_revenue
FROM billing b
JOIN encounters e ON b.encounter_id = e.encounter_id
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY 1, 2;

Schema Analysis:
Tables joined: billing, encounters, providers, specialties
Number of joins: 3
Performance:
Execution time: 0.0005 seconds
Bottleneck Identified:
Requires traversing the chain from billing -> encounters -> providers -> specialties. 
Aggregating financial data requires summing up large numbers of rows after these joins are performed.
