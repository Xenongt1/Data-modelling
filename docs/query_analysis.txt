QUESTION 1: Monthly Encounters by Specialty
SQL Query:
SELECT 
    DATE_FORMAT(e.encounter_date, '%Y-%m') as month,
    s.specialty_name,
    e.encounter_type,
    COUNT(e.encounter_id) as total_encounters,
    COUNT(DISTINCT e.patient_id) as unique_patients
FROM encounters e
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY 1, 2, 3
ORDER BY 1, 2, 3

Schema Analysis:
Tables joined: encounters, providers, specialties
Number of joins: 2
Performance:
Execution time: 0.2203 seconds
Estimated rows scanned: 594
Rows returned: 450
Bottleneck Identified:
Efficient query with covering indexes. The database uses index lookups on provider_id and specialty_id, 
scanning only 594 rows to produce 450 results. This is a well-optimized query for the OLTP schema.

---------------------------------------------------

QUESTION 2: Top Diagnosis-Procedure Pairs
SQL Query:
SELECT 
    d.icd10_code,
    p.cpt_code,
    COUNT(e.encounter_id) as overlap_count
FROM encounters e
JOIN encounter_diagnoses ed ON e.encounter_id = ed.encounter_id
JOIN diagnoses d ON ed.diagnosis_id = d.diagnosis_id
JOIN encounter_procedures ep ON e.encounter_id = ep.encounter_id
JOIN procedures p ON ep.procedure_id = p.procedure_id
GROUP BY 1, 2
ORDER BY 3 DESC
LIMIT 10

Schema Analysis:
Tables joined: encounters, encounter_diagnoses, diagnoses, encounter_procedures, procedures
Number of joins: 4
Performance:
Execution time: 1.2128 seconds
Estimated rows scanned: 30,169
Rows returned: 10
Bottleneck Identified:
CRITICAL: Row Explosion. Joining two many-to-many junction tables (diagnoses and procedures) through 
the encounter table causes a Cartesian product for each encounter (e.g., 3 diagnoses * 2 procedures = 6 
rows per encounter), which then has to be aggregated back down. This is the slowest query in the OLTP 
schema and demonstrates the key weakness of normalized schemas for complex analytical queries.

---------------------------------------------------

QUESTION 3: 30-Day Readmission Rate
SQL Query:
SELECT 
    s.specialty_name,
    COUNT(DISTINCT initial.encounter_id) as index_admissions,
    COUNT(DISTINCT readmit.encounter_id) as readmissions,
    (COUNT(DISTINCT readmit.encounter_id) / COUNT(DISTINCT initial.encounter_id)) * 100 as readmission_rate
FROM encounters initial
JOIN providers p ON initial.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
LEFT JOIN encounters readmit ON initial.patient_id = readmit.patient_id
    AND readmit.encounter_date > initial.discharge_date
    AND readmit.encounter_date <= DATE_ADD(initial.discharge_date, INTERVAL 30 DAY)
WHERE initial.encounter_type = 'Inpatient'
GROUP BY 1
ORDER BY 4 DESC

Schema Analysis:
Tables joined: encounters (x2), providers, specialties
Number of joins: 3 (including 1 self-join)
Performance:
Execution time: 0.1796 seconds
Estimated rows scanned: 30,170
Rows returned: 6
Bottleneck Identified:
Self-Join with date range filtering. The query scans the entire encounters table (~30K rows) to find 
readmissions within 30 days. While not as slow as originally estimated, this query would benefit from 
a composite index on (patient_id, encounter_date, discharge_date, encounter_type).

---------------------------------------------------

QUESTION 4: Revenue by Specialty & Month
SQL Query:
SELECT 
    DATE_FORMAT(b.claim_date, '%Y-%m') as month,
    s.specialty_name,
    SUM(b.allowed_amount) as total_revenue
FROM billing b
JOIN encounters e ON b.encounter_id = e.encounter_id
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
WHERE b.claim_status = 'Paid'
GROUP BY 1, 2
ORDER BY 1, 3 DESC

Schema Analysis:
Tables joined: billing, encounters, providers, specialties
Number of joins: 3
Performance:
Execution time: 0.1555 seconds
Estimated rows scanned: 30,174
Rows returned: 154
Bottleneck Identified:
Multiple joins required to link Revenue (Billing) to the grouping dimension (Specialty). The query 
performs a full table scan on billing and joins through encounters and providers to reach specialties. 
Relatively efficient for the OLTP schema.

---------------------------------------------------

OVERALL OLTP PERFORMANCE SUMMARY:
Total Execution Time: 1.7682 seconds
Average Query Time: 0.4421 seconds
Total Rows Scanned: 91,107
Queries: 4

Key Findings:
- Q2 (Diagnosis-Procedure Pairs) is the slowest at 1.21s due to many-to-many join complexity
- Q3 (Readmission Rate) scans the most rows (30,170) but executes reasonably fast
- Q1 and Q4 are well-optimized with good index usage
- The OLTP schema is efficient for simple queries but struggles with complex analytical patterns
