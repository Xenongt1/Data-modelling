Decision 1: Fact Table Grain
Choice: Option A: One row per encounter
Justification:
Most of our analytical queries (Q1, Q3, Q4) are centered around the 'Encounter' as the fundamental unit of activity (Counts, Readmissions, Revenue).
- Option B (Diagnosis Grain) would duplicate revenue and encounter details, making sum/count queries harder (requiring distinct/averaging).
- Option C (Procedure Grain) suffers the same issue.
Option A is the cleanest for standard reporting. We will handle the "Many" relationships (Diagnoses/Procedures) using Bridge Tables.

Decision 2: Dimension Tables (Denormalization Strategy)
We will create the following dimensions:
1. dim_date (Generated via Stored Procedure)
   - date_key (PK, YYYYMMDD), full_date, year, month, quarter, etc.
2. dim_patient (SCD Type 1)
   - patient_id (Natural Key), name, dob, gender, current_age (Calculated).
3. dim_provider
   - Flattened hierarchy: provider joined with specialty and department.
   - Eliminates need for "Snowflake" joins during analysis.
4. dim_encounter_type, dim_diagnosis, dim_procedure.

Decision 3: Pre-Aggregated Metrics (Storage vs Compute Trade-off)
In `fact_encounters`, we decided to PRE-CALCULATE heavily to simplfy report queries:
1. `total_claim_amount` & `total_allowed_amount`: Aggregated via SUM() during ETL. Solves the 1:Many billing issue and prevents report duplication.
2. `diagnosis_count` & `procedure_count`: Integer counts stored on the fact table. Allows filtering for "Complex Cases" without touching bridge tables.
3. `length_of_stay`: Stored as INT (Rounded). Calculated as Datetime Difference / 86400.

Decision 4: ETL Strategy
Choice: SQL-Based ELT (Extract, Load, Transform).
Justification:
- Performance: Set-based SQL updates are significantly faster than row-by-row Python processing for bulk loads.
- Simplicity: Logic resides in the database (`production_etl.sql`), making it independent of the application layer.

Decision 5: Bridge Tables (Handling Many-to-Many)
Choice: Standard Bridge Table Pattern
1. `bridge_encounter_diagnoses`:
   - Links `encounter_key` to `diagnosis_key`.
   - Includes `diagnosis_sequence` (Primary, Secondary, etc.) to allow filtering by rank.
2. `bridge_encounter_procedures`:
   - Links `encounter_key` to `procedure_key`.
   - Includes `procedure_date_key` to track timing of specific interventions within an encounter.

Decision 6: Date Denormalization (Smart Keys)
Choice: Duplicate 'encounter_date' on the Fact Table (Degenerate Dimension).
Justification:
- Problem: Joining `dim_date` for every query involving a date filter or grouping proved to be a performance bottleneck (0.3x slowdown).
- Solution: Store the actual DATE value directly on `fact_encounters`.
- Benefit: 
    - Eliminates the need to join `dim_date` for simple queries (e.g., Monthly Aggregation, Date Range filtering).
    - Preserves `dim_date` for complex calendar logic (Holidays, Fiscal Quarters), but removes it from the critical path of high-volume operational queries.
    - Aligns with modern EDW best practices (e.g., Partitioning keys in BigQuery/Snowflake often require the date value).

Decision 7: Revenue Reporting Basis (Cash vs. Accrual)
Choice: Report Revenue based on 'claim_date' (Cash Basis).
Justification:
- Requirement:revenue reports to reflect when money was *collected* (or likely collected), not just when service was provided.
- Implementation: Added `claim_date` as a Smart Key to `fact_encounters`.
- Logic: 
    - `claim_date` is populated from the Billing system.
    - NULL `claim_date` implies "Unpaid" or "Pending".
    - `total_allowed_amount` is only aggregated for 'Paid' claims.
- Benefit: Allows for accurate financial reconciliation against bank deposits (Cash Flow analysis) while maintaining the connection to clinical data (Encounter details).
