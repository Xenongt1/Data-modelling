Overview
We rewrote the 4 business queries to target the new Star Schema (`medical_dw`). Below is the performance comparison against the normalized OLTP schema (`medical_oltp`) based on your latest run.
Note: Dataset size is ~30,000 encounters.

---------------------------------------------------
Query 1: Monthly Encounters by Specialty
Star SQL:
SELECT 
    d.month_name,
    s.specialty_name,
    t.encounter_type_name,
    COUNT(f.encounter_key) as total_encounters,
    COUNT(DISTINCT f.patient_key) as unique_patients
FROM fact_encounters f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_specialty s ON f.specialty_key = s.specialty_key
JOIN dim_encounter_type t ON f.encounter_type_key = t.encounter_type_key
GROUP BY d.year, d.month, d.month_name, s.specialty_name, t.encounter_type_name;

Performance:
OLTP Time: 0.0741s
Star Time: 0.0627s
Result: ~1.2x Faster

Explanation:
Slight improvement. The Star Schema's efficient joins countered the overhead of the extra date dimension table.

---------------------------------------------------
Query 2: Top Diagnosis-Procedure Pairs
Star SQL:
SELECT 
    dd.icd10_code,
    dp.cpt_code,
    COUNT(bd.encounter_key) as overlap_count
FROM bridge_encounter_diagnoses bd
JOIN bridge_encounter_procedures bp ON bd.encounter_key = bp.encounter_key
JOIN dim_diagnosis dd ON bd.diagnosis_key = dd.diagnosis_key
JOIN dim_procedure dp ON bp.procedure_key = dp.procedure_key
GROUP BY 1, 2
ORDER BY 3 DESC
LIMIT 10;

Performance:
OLTP Time: 0.0908s
Star Time: 0.0859s
Result: ~1.05x Faster

Explanation:
Both queries were fast on this run (likely due to caching), but the Star Schema still edges out the OLTP version by bypassing the main table.

---------------------------------------------------
Query 3: 30-Day Readmission Rate
Star SQL:
SELECT 
    s.specialty_name,
    COUNT(DISTINCT f1.encounter_key) as index_admissions,
    COUNT(DISTINCT f2.encounter_key) as readmissions,
    (COUNT(DISTINCT f2.encounter_key) / COUNT(DISTINCT f1.encounter_key)) * 100 as rate
FROM fact_encounters f1
JOIN dim_specialty s ON f1.specialty_key = s.specialty_key
JOIN dim_date d1 ON f1.date_key = d1.date_key
LEFT JOIN fact_encounters f2 ON f1.patient_key = f2.patient_key
    AND f2.encounter_key > f1.encounter_key
    AND f2.date_key > f1.date_key
JOIN dim_date d2 ON f2.date_key = d2.date_key
WHERE f1.is_inpatient_flag = 1
    AND d2.full_date <= DATE_ADD(d1.full_date, INTERVAL 30 DAY)
GROUP BY 1
ORDER BY 4 DESC;

Performance:
OLTP Time: 17.0966s
Star Time: 0.0175s
Result: ~900x Faster

Explanation:
This is the massive win. The OLTP query likely hit a worst-case scenario with the self-join logic on the non-optimized schema. The Star Schema, with its pre-calculated flags and narrower table width, handled the self-join instantly.

---------------------------------------------------
Query 4: Revenue by Specialty & Month
Star SQL:
SELECT 
    d.month_name,
    s.specialty_name,
    SUM(f.allowed_amount) as total_revenue
FROM fact_encounters f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_specialty s ON f.specialty_key = s.specialty_key
GROUP BY d.year, d.month, d.month_name, s.specialty_name
ORDER BY d.year, d.month, 3 DESC;

Performance:
OLTP Time: 0.0234s
Star Time: 0.0302s
Result: ~1.3x Slower (Small Dataset Artifact)

Explanation:
The OLTP query is very simple here (Join Billing -> Encounters). The Star Schema requires joining the Date Dimension. On small data (30k rows), the cost of that one extra join is visible. On millions of rows, the pre-aggregated metrics in the Star Schema would win easily.
